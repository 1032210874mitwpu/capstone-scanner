from flask import Flask, request, render_template, send_from_directory, jsonify
import joblib, sqlite3, os, sys
from datetime import datetime
from werkzeug.utils import secure_filename
from collections import defaultdict


# Initialize Flask app with explicit settings
app = Flask(__name__, 
            template_folder=os.path.abspath('templates'),
            static_folder=os.path.abspath('static'))

app.config.update({
    'UPLOAD_FOLDER': 'reports',
    'MAX_CONTENT_LENGTH': 16 * 1024 * 1024,
    'SEND_FILE_MAX_AGE_DEFAULT': 0  # Disable caching for development
})

# Debugging header
print("\n" + "="*50)
print("Starting AI Vulnerability Scanner")
print("="*50 + "\n")

# Load ML models with validation
MODELS = {}
try:
    print("Loading machine learning models...")
    MODELS['rf'] = joblib.load('models/rf_model.pkl')
    MODELS['svm'] = joblib.load('models/svm_model.pkl')
    MODELS['nn'] = joblib.load('models/nn_model.pkl')
    MODELS['tfidf'] = joblib.load('models/tfidf.pkl')
    MODELS['encoder'] = joblib.load('models/label_encoder.pkl')
    print("✓ Models loaded successfully\n")
except Exception as e:
    print(f"✗ Error loading models: {str(e)}")
    sys.exit(1)

# Vulnerability severity mapping
SEVERITY_MAP = {
    'Cross-site Scripting': {'level': 'High', 'color': 'orange'},
    'SQL Injection': {'level': 'Critical', 'color': 'red'},
    'CSRF': {'level': 'Medium', 'color': 'yellow'},
    'Default': {'level': 'Low', 'color': 'blue'}
}

def create_db_connection():
    """Create and return a database connection"""
    conn = None
    try:
        conn = sqlite3.connect('db/scans.db')
        conn.execute('''CREATE TABLE IF NOT EXISTS scans
                      (id INTEGER PRIMARY KEY AUTOINCREMENT,
                      url TEXT NOT NULL,
                      timestamp TEXT NOT NULL,
                      results TEXT NOT NULL)''')
        return conn
    except Exception as e:
        print(f"Database error: {str(e)}")
        if conn:
            conn.close()
        return None
@app.before_request
def log_request():
    print(f"\nIncoming request: {request.method} {request.path}")
    print(f"Template folder: {app.template_folder}")
    print(f"Static folder: {app.static_folder}")
    
@app.route('/debug')
def debug():
    """Debug endpoint to check paths"""
    return jsonify({
        'working_directory': os.getcwd(),
        'template_files': os.listdir(app.template_folder),
        'static_files': os.listdir(app.static_folder),
        'templates_exist': os.path.exists('templates/dashboard.html'),
        'static_exists': os.path.exists('static/style.css')
    })

@app.route('/test-template')
def test_template():
    """Test template rendering"""
    try:
        return render_template('dashboard.html')
    except Exception as e:
        return f"Template error: {str(e)}", 500
    
@app.route('/')
def home():
    """Main dashboard page"""
    system_status = {
        'models_loaded': True if MODELS else False,
        'db_connected': os.path.exists('db/scans.db')
    }
    return render_template('dashboard.html', 
                         data={'system_status': system_status},
                         severity_map=SEVERITY_MAP)

@app.route('/scan', methods=['POST'])
def scan():
    """Handle scan requests"""
    if 'url' not in request.form:
        return jsonify({'error': 'No URL provided'}), 400

    url = request.form['url'].strip()
    if not url.startswith(('http://', 'https://')):
        url = f'http://{url}'

    print(f"\nStarting scan for: {url}")

    # Initialize report structure
    report = {
        'url': url,
        'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        'results': defaultdict(dict),
        'signatures': []
    }

    # Process through each model
    for name, model_key in [('Random Forest', 'rf'),
                           ('SVM', 'svm'),
                           ('Neural Network', 'nn')]:
        try:
            # Vectorize input
            features = MODELS['tfidf'].transform([url])
            
            # Get prediction
            pred = MODELS[model_key].predict(features)[0]
            if hasattr(MODELS['encoder'], 'inverse_transform'):
                pred = MODELS['encoder'].inverse_transform([pred])[0]
            
            # Get confidence
            proba = MODELS[model_key].predict_proba(features)[0]
            confidence = round(max(proba) * 100, 2)
            
            # Store results
            report['results'][name] = {
                'prediction': pred,
                'confidence': confidence,
                'severity': SEVERITY_MAP.get(pred, SEVERITY_MAP['Default'])
            }
            
        except Exception as e:
            print(f"! {name} model failed: {str(e)}")
            report['results'][name] = {
                'prediction': 'Error',
                'confidence': 0,
                'severity': SEVERITY_MAP['Default']
            }

    # Generate consensus
    if report['results']:
        pred_counts = defaultdict(int)
        for model in report['results'].values():
            pred_counts[model['prediction']] += 1
        
        consensus = max(pred_counts.items(), key=lambda x: x[1])[0]
        avg_conf = round(sum(m['confidence'] for m in report['results'].values()) / len(report['results']), 2)
        
        report['consensus'] = {
            'vulnerability': consensus,
            'confidence': avg_conf,
            'severity': SEVERITY_MAP.get(consensus, SEVERITY_MAP['Default'])
        }

    # Save to database
    conn = create_db_connection()
    if conn:
        try:
            conn.execute(
                "INSERT INTO scans (url, timestamp, results) VALUES (?, ?, ?)",
                (url, report['timestamp'], str(report['results']))
            )
            conn.commit()
        except Exception as e:
            print(f"! Database insert failed: {str(e)}")
        finally:
            conn.close()

    # Generate PDF report
    os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
    filename = secure_filename(f"scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf")
    report_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
    
    from report.generate_report import generate_pdf
    generate_pdf(report, report_path)

    return jsonify({
        'status': 'completed',
        'report': report,
        'download': f'/download/{filename}'
    })

@app.route('/download/<filename>')
def download(filename):
    """Serve generated reports"""
    try:
        return send_from_directory(
            app.config['UPLOAD_FOLDER'],
            filename,
            as_attachment=True,
            mimetype='application/pdf'
        )
    except Exception as e:
        return jsonify({'error': str(e)}), 404

@app.route('/history')
def history():
    """Retrieve scan history"""
    conn = create_db_connection()
    if not conn:
        return jsonify({'error': 'Database unavailable'}), 500
        
    try:
        scans = conn.execute(
            "SELECT url, timestamp, results FROM scans ORDER BY timestamp DESC LIMIT 20"
        ).fetchall()
        return jsonify([dict(zip(['url', 'timestamp', 'results'], scan)) for scan in scans])
    except Exception as e:
        return jsonify({'error': str(e)}), 500
    finally:
        conn.close()

if __name__ == '__main__':
    # Check for port conflicts
    try:
        print("\nStarting Flask server...")
        print(f"Access at: http://127.0.0.1:5000")
        app.run(
            host='127.0.0.1',
            port=5000,
            debug=True,
            use_reloader=False,  # Disable reloader to prevent double instances
            threaded=True
        )
    except OSError as e:
        if "Address already in use" in str(e):
            print("\nERROR: Port 5000 is already in use")
            print("Try these solutions:")
            print("1. Wait 30 seconds and try again")
            print("2. Change the port: app.run(port=5001)")
            print("3. Find and kill the process:")
            print("   netstat -ano | findstr 5000")
            print("   taskkill /PID [PID] /F")
        else:
            print(f"Fatal error: {str(e)}")